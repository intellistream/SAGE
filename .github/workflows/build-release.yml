name: Build and Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  release:
    types: [published]

permissions:
  contents: read
  packages: write

env:
  PYTHON_VERSION: '3.11'
  
jobs:
  build:
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      wheel-name: ${{ steps.build.outputs.wheel-name }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build setuptools wheel tomli
        # Install project dependencies from pyproject.toml
        pip install -e ".[dev]"
        
    - name: Get version
      id: version
      run: |
        # ‰ªépyproject.toml‰∏≠ÊèêÂèñÁâàÊú¨Âè∑ (ÂÖºÂÆπPython 3.11)
        VERSION=$(python -c "
        try:
            import tomllib
        except ImportError:
            import tomli as tomllib
        with open('pyproject.toml', 'rb') as f:
            data = tomllib.load(f)
            print(data['project']['version'])
        " 2>/dev/null || echo "0.1.0")
        
        # Â¶ÇÊûúÊòØtagËß¶ÂèëÔºå‰ΩøÁî®tagÁâàÊú¨
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
        
    - name: Build C extensions
      run: |
        echo "üîç Searching for C extensions..."
        
        # Êü•ÊâæÂèØËÉΩÁöÑCÊâ©Â±ïÁõÆÂΩï
        found_extensions=false
        
        # Ê£ÄÊü•packagesÁõÆÂΩï‰∏ãÁöÑCÊâ©Â±ï
        for pkg_dir in packages/*/; do
          if [ -d "$pkg_dir" ]; then
            echo "Checking $pkg_dir for C extensions..."
            if find "$pkg_dir" -name "*.c" -o -name "*.cpp" -o -name "setup.py" -o -name "build.sh" | grep -q .; then
              echo "Found C extensions in $pkg_dir"
              cd "$pkg_dir"
              
              if [ -f "build.sh" ]; then
                echo "Running build.sh in $pkg_dir"
                bash build.sh
                found_extensions=true
              elif [ -f "setup.py" ]; then
                echo "Building with setup.py in $pkg_dir"
                python setup.py build_ext --inplace
                found_extensions=true
              fi
              
              cd - > /dev/null
            fi
          fi
        done
        
        if [ "$found_extensions" = false ]; then
          echo "No C extensions found, skipping C extension build"
        else
          echo "C extensions build completed"
        fi
        
    - name: Build source wheel
      id: build-source
      run: |
        echo "Building source wheel..."
        python -m build --sdist --wheel
        
        # Ëé∑ÂèñÁîüÊàêÁöÑwheelÊñá‰ª∂Âêç
        WHEEL_FILE=$(ls dist/*.whl | head -1)
        WHEEL_NAME=$(basename "$WHEEL_FILE")
        
        echo "source-wheel=$WHEEL_NAME" >> $GITHUB_OUTPUT
        echo "Source wheel: $WHEEL_NAME"
        
    - name: Build bytecode wheel
      id: build
      run: |
        echo "Building bytecode wheel..."
        python build_wheel.py --clean
        
        # Ëé∑ÂèñÁîüÊàêÁöÑbytecode wheelÊñá‰ª∂Âêç
        BYTECODE_WHEEL=$(ls dist/*_bytecode.whl | head -1 || echo "")
        if [ -n "$BYTECODE_WHEEL" ]; then
          BYTECODE_NAME=$(basename "$BYTECODE_WHEEL")
          echo "wheel-name=$BYTECODE_NAME" >> $GITHUB_OUTPUT
          echo "Bytecode wheel: $BYTECODE_NAME"
        else
          echo "No bytecode wheel found, using source wheel"
          WHEEL_FILE=$(ls dist/*.whl | grep -v _bytecode | head -1)
          WHEEL_NAME=$(basename "$WHEEL_FILE")
          echo "wheel-name=$WHEEL_NAME" >> $GITHUB_OUTPUT
        fi
        
    - name: Verify wheel contents
      run: |
        echo "Verifying wheel contents..."
        pip install wheel
        
        for wheel_file in dist/*.whl; do
          echo "=== Contents of $(basename $wheel_file) ==="
          python -m wheel unpack "$wheel_file" --dest temp_unpack
          find temp_unpack -type f -name "*.so" | head -10
          find temp_unpack -type f -name "*.py" | head -10
          rm -rf temp_unpack
          echo ""
        done
        
    - name: Test wheel installation
      run: |
        echo "Testing wheel installation..."
        
        # ÂàõÂª∫ËôöÊãüÁéØÂ¢ÉËøõË°åÊµãËØï
        python -m venv test_env
        source test_env/bin/activate
        
        # ÂÆâË£Öwheel
        WHEEL_FILE=$(ls dist/*.whl | head -1)
        pip install "$WHEEL_FILE"
        
        # Âü∫Êú¨ÂØºÂÖ•ÊµãËØï
        python -c "import sage; print('SAGE imported successfully')"
        
        # ÊµãËØïCÊâ©Â±ïÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        python -c "
        try:
            from sage.utils.mmap_queue import ring_buffer
            print('C extension imported successfully')
        except ImportError as e:
            print(f'C extension import failed: {e}')
        except Exception as e:
            print(f'C extension error: {e}')
        " || true
        
        deactivate
        rm -rf test_env
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sage-wheels-${{ steps.version.outputs.version }}
        path: |
          dist/*.whl
          dist/*.tar.gz
        retention-days: 90
        
  test:
    needs: build
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: sage-wheels-${{ needs.build.outputs.version }}
        path: dist/
        
    - name: Install and test wheel
      run: |
        pip install pytest
        
        # ÂÆâË£ÖÊûÑÂª∫ÁöÑwheel
        WHEEL_FILE=$(ls dist/*.whl | head -1)
        pip install "$WHEEL_FILE"
        
        # ËøêË°åÂü∫Êú¨ÊµãËØï
        python -c "import sage; print(f'SAGE version: {getattr(sage, \"__version__\", \"unknown\")}')"
        
        # Â¶ÇÊûúÊúâÊµãËØïÊñá‰ª∂ÔºåËøêË°åÂÆÉ‰ª¨
        if [ -d "tests" ]; then
          pytest tests/ -v
        fi
        
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [build, test]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: sage-wheels-${{ needs.build.outputs.version }}
        path: dist/
        
    - name: Create Release
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Ëé∑ÂèñÊâÄÊúâwheelÊñá‰ª∂
          const distDir = 'dist';
          const files = fs.readdirSync(distDir);
          const wheelFiles = files.filter(f => f.endsWith('.whl'));
          const tarFiles = files.filter(f => f.endsWith('.tar.gz'));
          
          // ÂàõÂª∫release
          const tag = context.ref.replace('refs/tags/', '');
          const release = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: tag,
            name: `SAGE ${tag}`,
            body: `
          ## SAGE ${tag}
          
          This is a closed-source release of SAGE including compiled C extensions.
          
          ### üì¶ Assets
          ${wheelFiles.map(f => `- \`${f}\` - Binary wheel package`).join('\n')}
          ${tarFiles.map(f => `- \`${f}\` - Source distribution`).join('\n')}
          
          ### üìã Installation
          \`\`\`bash
          pip install ${wheelFiles[0] || 'sage'}
          \`\`\`
          
          ### ‚ö†Ô∏è Note
          This is a closed-source distribution. The source code and C extensions are compiled to bytecode.
            `,
            draft: false,
            prerelease: tag.includes('rc') || tag.includes('beta') || tag.includes('alpha')
          });
          
          // ‰∏ä‰º†assets
          for (const file of [...wheelFiles, ...tarFiles]) {
            const filePath = path.join(distDir, file);
            const content = fs.readFileSync(filePath);
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: file,
              data: content
            });
            
            console.log(`Uploaded ${file}`);
          }
          
    - name: Publish to private registry
      if: env.PRIVATE_REGISTRY_URL != ''
      env:
        PRIVATE_REGISTRY_URL: ${{ secrets.PRIVATE_REGISTRY_URL }}
        PRIVATE_REGISTRY_TOKEN: ${{ secrets.PRIVATE_REGISTRY_TOKEN }}
      run: |
        echo "Publishing to private registry..."
        
        # ÈÖçÁΩÆÁßÅÊúâ‰ªìÂ∫ì
        pip install twine
        
        # ‰∏ä‰º†Âà∞ÁßÅÊúâ‰ªìÂ∫ì
        python -m twine upload \
          --repository-url "$PRIVATE_REGISTRY_URL" \
          --username __token__ \
          --password "$PRIVATE_REGISTRY_TOKEN" \
          dist/*.whl
          
        echo "Published to private registry successfully"
        
  cleanup:
    if: always()
    needs: [build, test, release]
    runs-on: ubuntu-latest
    
    steps:
    - name: Clean up old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          // Ê∏ÖÁêÜË∂ÖËøá30Â§©ÁöÑartifacts
          const artifacts = await github.rest.actions.listArtifactsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          for (const artifact of artifacts.data.artifacts) {
            const createdAt = new Date(artifact.created_at);
            if (createdAt < thirtyDaysAgo) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
              console.log(`Deleted old artifact: ${artifact.name}`);
            }
          }
