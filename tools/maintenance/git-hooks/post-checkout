#!/usr/bin/env bash
set -euo pipefail

# Git passes three arguments to post-checkout; they are not required for this hook.
# shellcheck disable=SC2034
old_ref="$1"
# shellcheck disable=SC2034
new_ref="$2"
# shellcheck disable=SC2034
checkout_type="$3"

repo_root="$(git rev-parse --show-toplevel)"
if [[ -z "${repo_root}" ]]; then
  echo "[post-checkout] Unable to determine repository root" >&2
  exit 0
fi

script_path="$repo_root/tools/maintenance/helpers/manage_submodule_branches.sh"
if [[ ! -x "$script_path" ]]; then
  echo "[post-checkout] manage_submodule_branches.sh not executable; skipping submodule sync." >&2
  exit 0
fi

# Run the switch command to align submodule branches with the current checkout.
"$script_path" switch || {
  echo "[post-checkout] Failed to synchronize submodule branches" >&2
  exit 0
}

# å®šæœŸæ¸…ç†æé†’ï¼ˆæ¯30å¤©ï¼‰
cleanup_reminder_file="$repo_root/.sage/.last_cleanup_reminder"
current_time=$(date +%s)
reminder_interval=$((30 * 24 * 60 * 60))  # 30å¤©

should_remind=false
if [[ ! -f "$cleanup_reminder_file" ]]; then
  should_remind=true
else
  last_reminder=$(cat "$cleanup_reminder_file" 2>/dev/null || echo "0")
  time_diff=$((current_time - last_reminder))
  if [[ $time_diff -ge $reminder_interval ]]; then
    should_remind=true
  fi
fi

if [[ "$should_remind" == "true" ]]; then
  echo ""
  echo "ðŸ’¡ æç¤ºï¼šå·²ç»ä¸€æ®µæ—¶é—´æ²¡æœ‰æ¸…ç†ç¼“å­˜äº†ï¼Œå»ºè®®è¿è¡Œï¼š"
  echo "   ./manage.sh clean         # å¿«é€Ÿæ¸…ç†ç¼“å­˜å’Œç©ºç›®å½•"
  echo "   ./manage.sh clean-deep    # æ·±åº¦æ¸…ç†ï¼ˆåŒ…æ‹¬æ—¥å¿—ï¼‰"
  echo ""

  # æ›´æ–°æé†’æ—¶é—´
  mkdir -p "$(dirname "$cleanup_reminder_file")"
  echo "$current_time" > "$cleanup_reminder_file"
fi
