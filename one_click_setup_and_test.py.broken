#!/usr/bin/env python3
"""
SAGE Monorepo ä¸€é”®ç¯å¢ƒå®‰è£…å’Œæµ‹è¯•è„šæœ¬
=====================================

è¿™ä¸ªè„šæœ¬ä¼šï¼š
1. åˆ é™¤ç°æœ‰çš„æµ‹è¯•ç¯å¢ƒ
2. ä»å¤´åˆ›å»ºæ–°çš„è™šæ‹Ÿç¯å¢ƒ
3. ä½¿ç”¨æ–°çš„åŒ…ç®¡ç†å™¨å®‰è£…æ‰€æœ‰SAGEåŒ…
4. è¿è¡Œå®Œæ•´çš„æµ‹è¯•å¥—ä»¶
5. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š

ä½¿ç”¨æ–¹æ³•:
    python one_click_setup_and_test.py
    python one_click_setup_and_test.py --workers 8
    python one_click_setup_and_test.py --quick-test
"""

import os
import sys
import subprocess
import shutil
import argpars    def check_pytest_xdist(self, venv_python: Path) -> bool:
        """æ£€æŸ¥pytest-xdistæ˜¯å¦å¯ç”¨"""
        try:
            result = subprocess.run(
                [str(venv_python), "-c", "import xdist; print('available')"],
                capture_output=True,
                text=True
            )
            return result.returncode == 0 and "available" in result.stdout
        except:
            return False
    
    def run_tests(self, workers: int = 4, quick_test: bool = False, test_files: List[Path] = None, categorized_tests: Dict[str, List[Path]] = None):
import time
import re
import json
from pathlib import Path
from datetime import datetime
from typing import List, Set, Dict, Tuple

class TestFileCollector:
    """æ™ºèƒ½æµ‹è¯•æ–‡ä»¶æ”¶é›†å™¨"""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        
        # æµ‹è¯•æ–‡ä»¶æ¨¡å¼
        self.test_file_patterns = [
            r'test_.*\.py$',           # test_xxx.py
            r'.*_test\.py$',           # xxx_test.py  
            r'tests\.py$',             # tests.py
            r'test\.py$',              # test.py
        ]
        
        # éæµ‹è¯•æ–‡ä»¶æ¨¡å¼ (å³ä½¿åœ¨testsç›®å½•ä¸­ä¹Ÿè¦æ’é™¤)
        self.non_test_patterns = [
            r'__init__\.py$',          # __init__.py
            r'conftest\.py$',          # pytesté…ç½®æ–‡ä»¶
            r'setup\.py$',             # å®‰è£…è„šæœ¬
            r'run_.*\.py$',            # è¿è¡Œè„šæœ¬ (run_all_tests.py, run_tests.pyç­‰)
            r'migrate\.py$',           # è¿ç§»è„šæœ¬
            r'mock_.*\.py$',           # mockæ–‡ä»¶
            r'.*_setup\.py$',          # è®¾ç½®è„šæœ¬
            r'validate_.*\.py$',       # éªŒè¯è„šæœ¬
            r'quick_reference\.py$',   # å‚è€ƒæ–‡æ¡£
        ]
        
        # æµ‹è¯•ç›®å½•æ¨¡å¼
        self.test_directory_patterns = [
            r'.*/tests/.*',            # */tests/*
            r'.*/test/.*',             # */test/*
        ]
        
    def is_test_file(self, file_path: Path) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæµ‹è¯•æ–‡ä»¶"""
        file_str = str(file_path)
        filename = file_path.name
        
        # é¦–å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºéæµ‹è¯•æ–‡ä»¶
        for pattern in self.non_test_patterns:
            if re.search(pattern, filename, re.IGNORECASE):
                return False
        
        # æ£€æŸ¥æ˜¯å¦åœ¨æµ‹è¯•ç›®å½•ä¸­
        in_test_directory = any(
            re.search(pattern, file_str, re.IGNORECASE) 
            for pattern in self.test_directory_patterns
        )
        
        # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦ç¬¦åˆæµ‹è¯•æ¨¡å¼
        matches_test_pattern = any(
            re.search(pattern, filename, re.IGNORECASE)
            for pattern in self.test_file_patterns
        )
        
        return matches_test_pattern or in_test_directory
    
    def has_test_content(self, file_path: Path) -> bool:
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åŒ…å«æµ‹è¯•å†…å®¹"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(8192)  # åªè¯»å‰8KB
                
                # æ£€æŸ¥æ˜¯å¦åŒ…å«æµ‹è¯•ç›¸å…³çš„å¯¼å…¥å’Œç±»/å‡½æ•°
                test_indicators = [
                    r'import\s+(unittest|pytest)',
                    r'from\s+(unittest|pytest)',
                    r'class\s+Test\w+',
                    r'def\s+test_\w+',
                    r'@pytest\.',
                    r'assert\s+',
                    r'\.assertEqual\(',
                    r'\.assertTrue\(',
                    r'\.assertFalse\(',
                ]
                
                return any(re.search(pattern, content, re.IGNORECASE) for pattern in test_indicators)
        except:
            return False
    
    def collect_test_files(self) -> List[Path]:
        """æ”¶é›†æ‰€æœ‰æµ‹è¯•æ–‡ä»¶"""
        test_files = []
        
        # æ”¶é›†æ‰€æœ‰Pythonæ–‡ä»¶
        for py_file in self.project_root.rglob('*.py'):
            # è·³è¿‡è™šæ‹Ÿç¯å¢ƒå’Œæ„å»ºç›®å½•
            if any(part in str(py_file) for part in [
                'venv', '.venv', 'env', 'test_env', 'test_env_minimal',
                'build', 'dist', '.git', '__pycache__', '.pytest_cache'
            ]):
                continue
                
            # åŸºäºæ–‡ä»¶åå’Œè·¯å¾„åˆ¤æ–­
            if self.is_test_file(py_file):
                # è¿›ä¸€æ­¥éªŒè¯æ–‡ä»¶å†…å®¹
                if self.has_test_content(py_file):
                    test_files.append(py_file)
        
        return sorted(test_files)
    
    def categorize_test_files(self, test_files: List[Path]) -> Dict[str, List[Path]]:
        """æŒ‰åŒ…åˆ†ç±»æµ‹è¯•æ–‡ä»¶"""
        categories = {}
        
        for test_file in test_files:
            # ç¡®å®šæµ‹è¯•æ–‡ä»¶å±äºå“ªä¸ªåŒ…
            relative_path = test_file.relative_to(self.project_root)
            parts = relative_path.parts
            
            if 'packages' in parts:
                # åœ¨packagesç›®å½•ä¸­
                package_idx = parts.index('packages')
                if package_idx + 1 < len(parts):
                    package_name = parts[package_idx + 1]
                    category = f"packages/{package_name}"
                else:
                    category = "packages/unknown"
            elif 'app' in parts:
                category = "app"
            elif 'scripts' in parts:
                category = "scripts"
            else:
                category = "root"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(test_file)
        
        return categories


class OneClickSAGETester:
    """SAGE ä¸€é”®å®‰è£…å’Œæµ‹è¯•"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.venv_path = self.project_root / "test_env"
        self.test_logs_dir = self.project_root / "test_logs"
        self.reports_dir = self.project_root / "test_reports"
        self.test_collector = TestFileCollector(self.project_root)
        
    def print_header(self, title: str):
        """æ‰“å°æ ¼å¼åŒ–æ ‡é¢˜"""
        print(f"\n{'='*60}")
        print(f"ğŸš€ {title}")
        print(f"{'='*60}")
        
    def print_step(self, step: int, title: str):
        """æ‰“å°æ­¥éª¤"""
        print(f"\nğŸ“‹ æ­¥éª¤ {step}: {title}")
        print("-" * 40)
        
    def run_command(self, command: str, description: str) -> bool:
        """è¿è¡Œå‘½ä»¤"""
        print(f"ğŸ”§ {description}")
        print(f"ğŸ’» æ‰§è¡Œ: {command}")
        
        try:
            result = subprocess.run(command, shell=True, cwd=self.project_root)
            if result.returncode == 0:
                print("âœ… æˆåŠŸ")
                return True
            else:
                print(f"âŒ å¤±è´¥ (é€€å‡ºç : {result.returncode})")
                return False
        except Exception as e:
            print(f"âŒ å¼‚å¸¸: {e}")
            return False
            
    def cleanup_old_environment(self):
        """æ¸…ç†æ—§ç¯å¢ƒ"""
        self.print_step(1, "æ¸…ç†æ—§ç¯å¢ƒ")
        
        # åˆ é™¤è™šæ‹Ÿç¯å¢ƒ
        if self.venv_path.exists():
            print(f"ğŸ—‘ï¸  åˆ é™¤æ—§è™šæ‹Ÿç¯å¢ƒ: {self.venv_path}")
            shutil.rmtree(self.venv_path)
            print("âœ… æ—§è™šæ‹Ÿç¯å¢ƒå·²åˆ é™¤")
        else:
            print("â„¹ï¸  æ²¡æœ‰å‘ç°æ—§è™šæ‹Ÿç¯å¢ƒ")
            
        # æ¸…ç†æ—¥å¿—ç›®å½•
        if self.test_logs_dir.exists():
            print(f"ğŸ—‘ï¸  æ¸…ç†æµ‹è¯•æ—¥å¿—: {self.test_logs_dir}")
            shutil.rmtree(self.test_logs_dir)
            print("âœ… æµ‹è¯•æ—¥å¿—å·²æ¸…ç†")
            
        # æ¸…ç†Pythonç¼“å­˜
        cache_dirs = [
            "__pycache__",
            ".pytest_cache",
            "build",
            "dist",
            "*.egg-info"
        ]
        
        for pattern in cache_dirs:
            if pattern.startswith("*"):
                # glob pattern
                for item in self.project_root.glob(pattern):
                    if item.is_dir():
                        print(f"ğŸ—‘ï¸  åˆ é™¤ç¼“å­˜ç›®å½•: {item}")
                        shutil.rmtree(item)
            else:
                # exact directory name
                for item in self.project_root.rglob(pattern):
                    if item.is_dir():
                        print(f"ğŸ—‘ï¸  åˆ é™¤ç¼“å­˜ç›®å½•: {item}")
                        shutil.rmtree(item)
                        
        # æ¸…ç†ç¬¬ä¸‰æ–¹ä¾èµ–çš„æµ‹è¯•ç›®å½•ï¼Œé¿å…pytestå†²çª
        third_party_patterns = [
            "packages/**/build",
            "packages/**/_deps", 
            "packages/**/third_party",
            "packages/**/external"
        ]
        
        for pattern in third_party_patterns:
            for item in self.project_root.glob(pattern):
                if item.is_dir():
                    print(f"ğŸ—‘ï¸  æ¸…ç†ç¬¬ä¸‰æ–¹ä¾èµ–ç›®å½•: {item}")
                    try:
                        shutil.rmtree(item)
                    except Exception as e:
                        print(f"âš ï¸  æ— æ³•åˆ é™¤ {item}: {e}")
                        
        print("âœ… ç¯å¢ƒæ¸…ç†å®Œæˆ")
        
    def create_fresh_environment(self):
        """åˆ›å»ºæ–°ç¯å¢ƒ"""
        self.print_step(2, "åˆ›å»ºæ–°çš„è™šæ‹Ÿç¯å¢ƒ")
        
        # æ£€æŸ¥Pythonç‰ˆæœ¬
        python_version = subprocess.run(
            ["python3", "--version"], 
            capture_output=True, 
            text=True
        )
        print(f"ğŸ Pythonç‰ˆæœ¬: {python_version.stdout.strip()}")
        
        if not python_version.stdout or not any(v in python_version.stdout for v in ["3.10", "3.11", "3.12"]):
            print("âš ï¸  è­¦å‘Š: æ¨èä½¿ç”¨Python 3.10+")
            
        # æ£€æŸ¥æ˜¯å¦æ»¡è¶³æœ€ä½ç‰ˆæœ¬è¦æ±‚ 
        version_parts = python_version.stdout.split()
        if len(version_parts) >= 2:
            version_str = version_parts[1]  # "3.10.12"
            major, minor = map(int, version_str.split('.')[:2])
            if major < 3 or (major == 3 and minor < 10):
                print("âŒ é”™è¯¯: SAGEéœ€è¦Python 3.10æˆ–æ›´é«˜ç‰ˆæœ¬")
                return False
            
        # åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
        success = self.run_command(
            "python3 -m venv test_env",
            "åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ"
        )
        
        if not success:
            print("âŒ è™šæ‹Ÿç¯å¢ƒåˆ›å»ºå¤±è´¥")
            return False
            
        return True
        
    def discover_and_analyze_tests(self):
        """å‘ç°å’Œåˆ†ææµ‹è¯•æ–‡ä»¶"""
        self.print_step(2.5, "å‘ç°å’Œåˆ†ææµ‹è¯•æ–‡ä»¶")
        
        print("ğŸ” æ‰«æé¡¹ç›®ä¸­çš„æµ‹è¯•æ–‡ä»¶...")
        test_files = self.test_collector.collect_test_files()
        
        if not test_files:
            print("âš ï¸  æœªå‘ç°æµ‹è¯•æ–‡ä»¶")
            return [], {}
            
        print(f"âœ… å‘ç° {len(test_files)} ä¸ªæµ‹è¯•æ–‡ä»¶")
        
        # æŒ‰åŒ…åˆ†ç±»
        categorized_tests = self.test_collector.categorize_test_files(test_files)
        
        print("\nğŸ“‹ æµ‹è¯•æ–‡ä»¶åˆ†å¸ƒ:")
        for category, files in categorized_tests.items():
            print(f"  {category}: {len(files)} ä¸ªæ–‡ä»¶")
            for file_path in files[:3]:  # åªæ˜¾ç¤ºå‰3ä¸ª
                rel_path = file_path.relative_to(self.project_root)
                print(f"    - {rel_path}")
            if len(files) > 3:
                print(f"    ... è¿˜æœ‰ {len(files) - 3} ä¸ªæ–‡ä»¶")
        
        # ä¿å­˜æµ‹è¯•æ–‡ä»¶åˆ—è¡¨åˆ°æ–‡ä»¶
        test_files_info = {
            "discovery_time": datetime.now().isoformat(),
            "total_files": len(test_files),
            "categories": {
                category: [str(f.relative_to(self.project_root)) for f in files]
                for category, files in categorized_tests.items()
            }
        }
        
        test_files_json = self.reports_dir / "discovered_test_files.json"
        self.reports_dir.mkdir(exist_ok=True)
        with open(test_files_json, 'w', encoding='utf-8') as f:
            json.dump(test_files_info, f, indent=2, ensure_ascii=False)
        
        print(f"ğŸ’¾ æµ‹è¯•æ–‡ä»¶ä¿¡æ¯å·²ä¿å­˜åˆ°: {test_files_json}")
        
        return test_files, categorized_tests
        
    def install_dependencies(self):
        """å®‰è£…ä¾èµ–"""
        self.print_step(3, "å®‰è£…é¡¹ç›®ä¾èµ–")
        
        # ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒä¸­çš„pythonå’Œpipç›´æ¥è°ƒç”¨ï¼Œé¿å…shellæ¿€æ´»é—®é¢˜
        venv_python = self.venv_path / "bin" / "python"
        venv_pip = self.venv_path / "bin" / "pip"
        
        # å‡çº§pip
        success = self.run_command(
            f"{venv_pip} install --upgrade pip",
            "å‡çº§pip"
        )
        
        if not success:
            print("âš ï¸  pipå‡çº§å¤±è´¥ï¼Œç»§ç»­å®‰è£…ä¾èµ–")
            
        # å®‰è£…é¡¹ç›®ä¾èµ– - ä½¿ç”¨æ–°çš„åŒ…ç®¡ç†å™¨
        success = self.run_command(
            f"{venv_python} scripts/sage-package-manager.py install-all --dev",
            "å®‰è£…æ‰€æœ‰SAGEåŒ…å’Œå¼€å‘ä¾èµ–"
        )
        
        if not success:
            print("âŒ ä¾èµ–å®‰è£…å¤±è´¥")
            return False
            
        # å®‰è£…æµ‹è¯•ä¾èµ–
        test_dependencies = [
            "pytest>=7.0.0",
            "pytest-xdist>=2.5.0",  # ç”¨äºå¹¶è¡Œæµ‹è¯•
            "pytest-cov>=4.0.0",    # ç”¨äºè¦†ç›–ç‡
            "pytest-mock>=3.10.0",  # ç”¨äºmock
        ]
        
        print("\nğŸ§ª å®‰è£…æµ‹è¯•ä¾èµ–...")
        for dep in test_dependencies:
            self.run_command(
                f"{venv_pip} install {dep}",
                f"å®‰è£… {dep}"
            )
            
        # æ˜¾ç¤ºå®‰è£…çš„åŒ…
        print("\nğŸ“¦ å·²å®‰è£…çš„åŒ…:")
        subprocess.run(
            f"{venv_pip} list | head -20",
            shell=True
        )
        
        return True
        
    def run_tests(self, workers: int = 16, quick_test: bool = False, test_files: List[Path] = None, categorized_tests: Dict[str, List[Path]] = None):
        """è¿è¡Œæµ‹è¯•"""
        mode = "å¿«é€Ÿæµ‹è¯•" if quick_test else "å®Œæ•´æµ‹è¯•"
        self.print_step(4, f"è¿è¡Œ{mode}")
        
        # ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒä¸­çš„pythonç›´æ¥è°ƒç”¨
        venv_python = self.venv_path / "bin" / "python"
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.test_logs_dir.mkdir(exist_ok=True)
        
        if quick_test:
            # å¿«é€Ÿæµ‹è¯•ï¼šç›´æ¥ä½¿ç”¨pytestè¿è¡Œä¸€å°éƒ¨åˆ†æµ‹è¯•æ–‡ä»¶
            if test_files and len(test_files) > 0:
                # é€‰æ‹©ä¸€äº›æœ‰ä»£è¡¨æ€§çš„æµ‹è¯•æ–‡ä»¶
                sample_tests = test_files[:min(5, len(test_files))]
                test_paths = [str(f.relative_to(self.project_root)) for f in sample_tests]
                
                print(f"ğŸ¯ è¿è¡Œå¿«é€Ÿæµ‹è¯• ({len(sample_tests)} ä¸ªæ–‡ä»¶)...")
                for test_path in test_paths:
                    print(f"  - {test_path}")
                
                success = self.run_command(
                    f"{venv_python} -m pytest {' '.join(test_paths)} -v --tb=short",
                    f"å¿«é€Ÿæµ‹è¯•æ‰§è¡Œ ({len(sample_tests)} ä¸ªæ–‡ä»¶)"
                )
                
                return success
            else:
                # å›é€€åˆ°åŸå§‹çš„å¿«é€Ÿæµ‹è¯•æ–¹æ³•
                print("âš ï¸  æœªå‘ç°æµ‹è¯•æ–‡ä»¶ï¼Œä½¿ç”¨åŸå§‹å¿«é€Ÿæµ‹è¯•æ–¹æ³•")
                success1 = self.run_command(
                    f"{venv_python} scripts/test_runner.py --diff",
                    "æ™ºèƒ½å·®å¼‚æµ‹è¯•"
                )
                
                success2 = self.run_command(
                    f"{venv_python} scripts/test_runner.py --list", 
                    "åˆ—å‡ºæµ‹è¯•æ–‡ä»¶"
                )
                
                return success1 and success2
        else:
            # å®Œæ•´æµ‹è¯•
            if test_files and len(test_files) > 0:
                print(f"ğŸš€ è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶ ({len(test_files)} ä¸ªæµ‹è¯•æ–‡ä»¶)...")
                
                # æŒ‰åŒ…åˆ†åˆ«è¿è¡Œæµ‹è¯•
                if categorized_tests:
                    overall_success = True
                    for category, files in categorized_tests.items():
                        if not files:
                            continue
                            
                        print(f"\nğŸ“¦ æµ‹è¯•åŒ…: {category} ({len(files)} ä¸ªæ–‡ä»¶)")
                        test_paths = [str(f.relative_to(self.project_root)) for f in files]
                        
                        success = self.run_command(
                            f"{venv_python} -m pytest {' '.join(test_paths)} -v --tb=short -n {min(workers, len(files))}",
                            f"æµ‹è¯• {category}"
                        )
                        
                        if not success:
                            print(f"âš ï¸  {category} æµ‹è¯•å¤±è´¥")
                            overall_success = False
                    
                    return overall_success
                else:
                    # æ‰€æœ‰æµ‹è¯•æ–‡ä»¶ä¸€èµ·è¿è¡Œ
                    test_paths = [str(f.relative_to(self.project_root)) for f in test_files]
                    success = self.run_command(
                        f"{venv_python} -m pytest {' '.join(test_paths)} -v --tb=short -n {workers}",
                        f"å®Œæ•´æµ‹è¯•æ‰§è¡Œ ({len(test_files)} ä¸ªæ–‡ä»¶)"
                    )
                    
                    return success
            else:
                # å›é€€åˆ°åŸå§‹çš„å®Œæ•´æµ‹è¯•æ–¹æ³•
                print("âš ï¸  æœªå‘ç°æµ‹è¯•æ–‡ä»¶ï¼Œä½¿ç”¨åŸå§‹å®Œæ•´æµ‹è¯•æ–¹æ³•")
                success = self.run_command(
                    f"{venv_python} scripts/test_runner.py --all --workers {workers}",
                    f"å®Œæ•´æµ‹è¯•æ‰§è¡Œ ({workers} workers)"
                )
                
                return success
            
    def generate_report(self, test_files: List[Path] = None, categorized_tests: Dict[str, List[Path]] = None):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        self.print_step(5, "ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š")
        
        # ç¡®ä¿æŠ¥å‘Šç›®å½•å­˜åœ¨
        self.reports_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = self.reports_dir / f"setup_and_test_report_{timestamp}.md"
        
        # è¯»å–æµ‹è¯•æ–‡ä»¶å‘ç°ä¿¡æ¯
        test_files_json = self.reports_dir / "discovered_test_files.json"
        test_discovery_info = {}
        if test_files_json.exists():
            try:
                with open(test_files_json, 'r', encoding='utf-8') as f:
                    test_discovery_info = json.load(f)
            except:
                pass
        
        # ç»Ÿè®¡æµ‹è¯•æ—¥å¿—
        log_files = list(self.test_logs_dir.glob("*.log")) if self.test_logs_dir.exists() else []
        passed_tests = 0
        failed_tests = 0
        
        for log_file in log_files:
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if "PASSED" in content and "FAILED" not in content:
                        passed_tests += 1
                    elif "FAILED" in content:
                        failed_tests += 1
            except:
                continue
                
        total_tests = len(log_files)
        success_rate = (passed_tests / max(total_tests, 1) * 100) if total_tests > 0 else 0
        
        # æ„å»ºæµ‹è¯•æ–‡ä»¶å‘ç°éƒ¨åˆ†
        test_discovery_section = ""
        if test_discovery_info:
            test_discovery_section = f"""
## ğŸ” æµ‹è¯•æ–‡ä»¶å‘ç°
- **å‘ç°æ—¶é—´**: {test_discovery_info.get('discovery_time', 'N/A')}
- **æ€»æµ‹è¯•æ–‡ä»¶æ•°**: {test_discovery_info.get('total_files', 0)} ä¸ª
- **åˆ†ç±»åˆ†å¸ƒ**:
"""
            categories = test_discovery_info.get('categories', {})
            for category, files in categories.items():
                test_discovery_section += f"  - **{category}**: {len(files)} ä¸ªæ–‡ä»¶\n"
                # åˆ—å‡ºå‰å‡ ä¸ªæ–‡ä»¶ä½œä¸ºç¤ºä¾‹
                for file_path in files[:3]:
                    test_discovery_section += f"    - `{file_path}`\n"
                if len(files) > 3:
                    test_discovery_section += f"    - ... è¿˜æœ‰ {len(files) - 3} ä¸ªæ–‡ä»¶\n"
                test_discovery_section += "\n"
        elif test_files:
            # ä½¿ç”¨ä¼ å…¥çš„æµ‹è¯•æ–‡ä»¶ä¿¡æ¯
            test_discovery_section = f"""
## ğŸ” æµ‹è¯•æ–‡ä»¶å‘ç°
- **æ€»æµ‹è¯•æ–‡ä»¶æ•°**: {len(test_files)} ä¸ª
"""
            if categorized_tests:
                test_discovery_section += "- **åˆ†ç±»åˆ†å¸ƒ**:\n"
                for category, files in categorized_tests.items():
                    test_discovery_section += f"  - **{category}**: {len(files)} ä¸ªæ–‡ä»¶\n"
                    for file_path in files[:3]:
                        rel_path = file_path.relative_to(self.project_root)
                        test_discovery_section += f"    - `{rel_path}`\n"
                    if len(files) > 3:
                        test_discovery_section += f"    - ... è¿˜æœ‰ {len(files) - 3} ä¸ªæ–‡ä»¶\n"
                    test_discovery_section += "\n"
        
        # ç”ŸæˆæŠ¥å‘Š
        report_content = f"""# SAGE ä¸€é”®å®‰è£…å’Œæµ‹è¯•æŠ¥å‘Š

## ğŸ“Š æ‰§è¡Œæ¦‚è§ˆ
- **æ‰§è¡Œæ—¶é—´**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
- **é¡¹ç›®è·¯å¾„**: {self.project_root}
- **Pythonç‰ˆæœ¬**: {subprocess.run(['python', '--version'], capture_output=True, text=True, cwd=self.venv_path / 'bin').stdout.strip() if (self.venv_path / 'bin').exists() else 'æœªçŸ¥'}

## ğŸ—ï¸ ç¯å¢ƒè®¾ç½®
- **è™šæ‹Ÿç¯å¢ƒ**: âœ… å·²åˆ›å»º ({self.venv_path})
- **ä¾èµ–å®‰è£…**: âœ… å·²å®Œæˆ
- **æµ‹è¯•è¿è¡Œå™¨**: âœ… å¯ç”¨
{test_discovery_section}
## ğŸ§ª æµ‹è¯•æ‰§è¡Œç»“æœ
- **æµ‹è¯•æ—¥å¿—æ–‡ä»¶**: {total_tests} ä¸ª
- **é€šè¿‡æµ‹è¯•**: {passed_tests} ä¸ª
- **å¤±è´¥æµ‹è¯•**: {failed_tests} ä¸ª
- **æˆåŠŸç‡**: {success_rate:.1f}%

## ğŸ“ˆ ç³»ç»Ÿä¿¡æ¯
- **CPUæ ¸å¿ƒæ•°**: {os.cpu_count()}
- **é¡¹ç›®ç»“æ„**: 
  - æµ‹è¯•ç›®å½•: {len(list(self.project_root.rglob('test*')))} ä¸ª
  - Pythonæ–‡ä»¶: {len(list(self.project_root.rglob('*.py')))} ä¸ª

## ğŸ“‹ åç»­ä½¿ç”¨
```bash
# æ¿€æ´»ç¯å¢ƒ
source test_env/bin/activate

# è¿è¡Œæµ‹è¯•
python scripts/test_runner.py --all

# æ™ºèƒ½æµ‹è¯•
python scripts/test_runner.py --diff

# æŸ¥çœ‹æ—¥å¿—
ls -la test_logs/
```

## ğŸš€ å¿«é€Ÿå‘½ä»¤
- **é‡æ–°è¿è¡Œæµ‹è¯•**: `python one_click_setup_and_test.py --quick-test`
- **å®Œæ•´æµ‹è¯•**: `python one_click_setup_and_test.py --workers 8`

---
*æŠ¥å‘Šç”±SAGEä¸€é”®å®‰è£…æµ‹è¯•è„šæœ¬ç”Ÿæˆ*
"""
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
            
        print(f"ğŸ“„ æµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ: {report_file}")
        return report_file
        
    def run_complete_setup(self, workers: int = 16, quick_test: bool = False):
        """è¿è¡Œå®Œæ•´çš„å®‰è£…å’Œæµ‹è¯•æµç¨‹"""
        start_time = time.time()
        
        self.print_header("SAGE ä¸€é”®ç¯å¢ƒå®‰è£…å’Œæµ‹è¯•")
        
        print("è¿™ä¸ªè„šæœ¬å°†:")
        print("âœ… åˆ é™¤ç°æœ‰æµ‹è¯•ç¯å¢ƒ")
        print("âœ… åˆ›å»ºæ–°çš„è™šæ‹Ÿç¯å¢ƒ")
        print("âœ… å®‰è£…æ‰€æœ‰é¡¹ç›®ä¾èµ–")
        print("âœ… è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶")
        print("âœ… ç”Ÿæˆè¯¦ç»†æµ‹è¯•æŠ¥å‘Š")
        
        # ç¡®è®¤ç»§ç»­
        try:
            response = input("\nâš ï¸  è¿™å°†åˆ é™¤ç°æœ‰çš„test_envç›®å½•ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ(y/N): ").strip().lower()
            if response not in ['y', 'yes']:
                print("âŒ æ“ä½œå·²å–æ¶ˆ")
                return False
        except KeyboardInterrupt:
            print("\nâŒ æ“ä½œå·²å–æ¶ˆ")
            return False
            
        success = True
        test_files = []
        categorized_tests = {}
        
        # æ­¥éª¤1: æ¸…ç†æ—§ç¯å¢ƒ
        self.cleanup_old_environment()
        
        # æ­¥éª¤2: åˆ›å»ºæ–°ç¯å¢ƒ
        if not self.create_fresh_environment():
            success = False
            
        # æ­¥éª¤2.5: å‘ç°å’Œåˆ†ææµ‹è¯•æ–‡ä»¶
        if success:
            test_files, categorized_tests = self.discover_and_analyze_tests()
            
        # æ­¥éª¤3: å®‰è£…ä¾èµ–
        if success and not self.install_dependencies():
            success = False
            
        # æ­¥éª¤4: è¿è¡Œæµ‹è¯•
        if success:
            test_success = self.run_tests(workers, quick_test, test_files, categorized_tests)
            if not test_success:
                print("âš ï¸  æµ‹è¯•æ‰§è¡Œæœ‰é—®é¢˜ï¼Œä½†ç»§ç»­ç”ŸæˆæŠ¥å‘Š")
                
        # æ­¥éª¤5: ç”ŸæˆæŠ¥å‘Š
        report_file = self.generate_report(test_files, categorized_tests)
        
        # æ€»ç»“
        end_time = time.time()
        duration = end_time - start_time
        
        self.print_header("å®‰è£…å’Œæµ‹è¯•å®Œæˆ")
        
        if success:
            print("ğŸ‰ SAGEç¯å¢ƒå®‰è£…å’Œæµ‹è¯•æˆåŠŸå®Œæˆï¼")
        else:
            print("âš ï¸  å®‰è£…è¿‡ç¨‹ä¸­é‡åˆ°ä¸€äº›é—®é¢˜ï¼Œè¯·æŸ¥çœ‹ä¸Šé¢çš„é”™è¯¯ä¿¡æ¯")
            
        print(f"â±ï¸  æ€»è€—æ—¶: {duration:.1f} ç§’")
        print(f"ğŸ“„ è¯¦ç»†æŠ¥å‘Š: {report_file}")
        print(f"ğŸ“Š æµ‹è¯•æ—¥å¿—: {self.test_logs_dir}")
        
        print("\nğŸš€ ç°åœ¨ä½ å¯ä»¥:")
        print("   â€¢ æ¿€æ´»ç¯å¢ƒ: source test_env/bin/activate  (bash) æˆ– . test_env/bin/activate  (sh)")
        print("   â€¢ è¿è¡Œæµ‹è¯•: test_env/bin/python scripts/test_runner.py --all")
        print("   â€¢ æŸ¥çœ‹æ—¥å¿—: ls -la test_logs/")
        
        return success

def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description="SAGE ä¸€é”®ç¯å¢ƒå®‰è£…å’Œæµ‹è¯•è„šæœ¬",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹ç”¨æ³•:
  python one_click_setup_and_test.py                   # é»˜è®¤è®¾ç½®å’Œå®Œæ•´æµ‹è¯•
  python one_click_setup_and_test.py --workers 8       # ä½¿ç”¨8ä¸ªå¹¶è¡Œè¿›ç¨‹
  python one_click_setup_and_test.py --quick-test      # å¿«é€Ÿæµ‹è¯•æ¨¡å¼
  python one_click_setup_and_test.py --discover-only   # ä»…å‘ç°æµ‹è¯•æ–‡ä»¶
        """
    )
    
    parser.add_argument(
        "--workers", 
        type=int, 
        default=4, 
        help="å¹¶è¡Œæµ‹è¯•è¿›ç¨‹æ•° (é»˜è®¤: 4)"
    )
    parser.add_argument(
        "--quick-test", 
        action="store_true", 
        help="è¿è¡Œå¿«é€Ÿæµ‹è¯•è€Œä¸æ˜¯å®Œæ•´æµ‹è¯•"
    )
    parser.add_argument(
        "--discover-only",
        action="store_true",
        help="ä»…å‘ç°å’Œåˆ†ææµ‹è¯•æ–‡ä»¶ï¼Œä¸è¿è¡Œæµ‹è¯•"
    )
    
    args = parser.parse_args()
    
    # æ£€æŸ¥æ˜¯å¦åœ¨æ­£ç¡®çš„ç›®å½•
    if not Path("packages").exists() or not Path("scripts/sage-package-manager.py").exists():
        print("âŒ é”™è¯¯: è¯·åœ¨SAGEé¡¹ç›®æ ¹ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬")
        print(f"å½“å‰ç›®å½•: {Path.cwd()}")
        print("åº”è¯¥åŒ…å«: packages/ ç›®å½•å’Œ scripts/sage-package-manager.py")
        sys.exit(1)
        
    if not Path("scripts/test_runner.py").exists():
        print("âš ï¸  è­¦å‘Š: scripts/test_runner.py ä¸å­˜åœ¨ï¼Œå°†ä½¿ç”¨åŸºæœ¬pytestæµ‹è¯•")
        print("ä½ å¯ä»¥æ‰‹åŠ¨è¿è¡Œ: python -m pytest æ¥æµ‹è¯•åŒ…")
        
    # åˆ›å»ºå¹¶è¿è¡Œä¸€é”®å®‰è£…æµ‹è¯•
    tester = OneClickSAGETester()
    
    try:
        if args.discover_only:
            # ä»…å‘ç°æµ‹è¯•æ–‡ä»¶
            print("ğŸ” ä»…è¿è¡Œæµ‹è¯•æ–‡ä»¶å‘ç°æ¨¡å¼")
            test_files, categorized_tests = tester.discover_and_analyze_tests()
            
            # ç”Ÿæˆç®€å•æŠ¥å‘Š
            if test_files:
                print(f"\nâœ… å‘ç° {len(test_files)} ä¸ªæµ‹è¯•æ–‡ä»¶")
                print("è¯¦ç»†ä¿¡æ¯å·²ä¿å­˜åˆ° test_reports/discovered_test_files.json")
                
                # ç”Ÿæˆç®€åŒ–æŠ¥å‘Š
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_file = tester.reports_dir / f"test_discovery_report_{timestamp}.md"
                tester.reports_dir.mkdir(exist_ok=True)
                
                with open(report_file, 'w', encoding='utf-8') as f:
                    f.write("# SAGE æµ‹è¯•æ–‡ä»¶å‘ç°æŠ¥å‘Š\n\n")
                    f.write(f"å‘ç°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"æ€»æ–‡ä»¶æ•°: {len(test_files)}\n\n")
                    
                    f.write("## æŒ‰åŒ…åˆ†ç±»\n\n")
                    for category, files in categorized_tests.items():
                        f.write(f"### {category} ({len(files)} ä¸ªæ–‡ä»¶)\n\n")
                        for file_path in files:
                            rel_path = file_path.relative_to(tester.project_root)
                            f.write(f"- `{rel_path}`\n")
                        f.write("\n")
                
                print(f"ğŸ“„ å‘ç°æŠ¥å‘Šå·²ä¿å­˜åˆ°: {report_file}")
                sys.exit(0)
            else:
                print("âŒ æœªå‘ç°ä»»ä½•æµ‹è¯•æ–‡ä»¶")
                sys.exit(1)
        else:
            success = tester.run_complete_setup(
                workers=args.workers,
                quick_test=args.quick_test
            )
            sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  æ“ä½œè¢«ç”¨æˆ·ä¸­æ–­")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ æ‰§è¡Œå‡ºé”™: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
