"""
测试 sage.apps.libs.io.source 模块
"""

import pytest
from unittest.mock import Mock, patch, MagicMock, mock_open
import json
import tempfile
import os

# 尝试导入IO模块
pytest_plugins = []

try:
    from sage.apps.libs.io_utils.source import (
        TextFileSource, JSONFileSource, CSVFileSource, 
        KafkaSource, DatabaseSource, APISource
    )
    IO_SOURCE_AVAILABLE = True
except ImportError as e:
    IO_SOURCE_AVAILABLE = False
    pytestmark = pytest.mark.skip(f"IO Source module not available: {e}")


@pytest.mark.unit
class TestTextFileSource:
    """测试TextFileSource类"""
    
    def test_text_file_source_import(self):
        """测试TextFileSource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import TextFileSource
        assert TextFileSource is not None
    
    def test_text_file_source_initialization(self, temp_dir):
        """测试TextFileSource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        file_path = os.path.join(temp_dir, "test.txt")
        config = {"file_path": file_path, "encoding": "utf-8"}
        
        try:
            source = TextFileSource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"TextFileSource initialization failed: {e}")
    
    def test_text_file_source_execute(self, temp_dir):
        """测试TextFileSource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 创建测试文件
        file_path = os.path.join(temp_dir, "test.txt")
        test_content = "这是测试文本内容\n第二行内容\n第三行内容"
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(test_content)
        
        config = {"file_path": file_path, "encoding": "utf-8"}
        
        try:
            source = TextFileSource(config=config)
            result = source.execute(None)
            
            # 验证结果
            assert isinstance(result, (str, list, dict))
            
        except Exception as e:
            pytest.skip(f"TextFileSource execution failed: {e}")
    
    @patch("builtins.open", new_callable=mock_open, read_data="mock file content")
    def test_text_file_source_with_mock(self, mock_file):
        """测试TextFileSource使用mock文件"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        config = {"file_path": "mock_file.txt", "encoding": "utf-8"}
        
        try:
            source = TextFileSource(config=config)
            result = source.execute(None)
            
            # 验证文件被打开
            mock_file.assert_called_once_with("mock_file.txt", 'r', encoding='utf-8')
            
        except Exception as e:
            pytest.skip(f"TextFileSource mock execution failed: {e}")


@pytest.mark.unit
class TestJSONFileSource:
    """测试JSONFileSource类"""
    
    def test_json_file_source_import(self):
        """测试JSONFileSource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import JSONFileSource
        assert JSONFileSource is not None
    
    def test_json_file_source_initialization(self, temp_dir):
        """测试JSONFileSource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        file_path = os.path.join(temp_dir, "test.json")
        config = {"file_path": file_path}
        
        try:
            source = JSONFileSource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"JSONFileSource initialization failed: {e}")
    
    def test_json_file_source_execute(self, temp_dir):
        """测试JSONFileSource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 创建测试JSON文件
        file_path = os.path.join(temp_dir, "test.json")
        test_data = {
            "name": "测试数据",
            "items": [
                {"id": 1, "text": "项目1"},
                {"id": 2, "text": "项目2"}
            ]
        }
        
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(test_data, f, ensure_ascii=False)
        
        config = {"file_path": file_path}
        
        try:
            source = JSONFileSource(config=config)
            result = source.execute(None)
            
            # 验证结果
            assert isinstance(result, (dict, list))
            
        except Exception as e:
            pytest.skip(f"JSONFileSource execution failed: {e}")
    
    def test_json_file_source_invalid_json(self, temp_dir):
        """测试JSONFileSource处理无效JSON"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 创建无效JSON文件
        file_path = os.path.join(temp_dir, "invalid.json")
        with open(file_path, 'w') as f:
            f.write("{ invalid json content")
        
        config = {"file_path": file_path}
        
        try:
            source = JSONFileSource(config=config)
            
            with pytest.raises((json.JSONDecodeError, Exception)):
                source.execute(None)
                
        except Exception as e:
            pytest.skip(f"JSONFileSource invalid JSON test failed: {e}")


@pytest.mark.unit
class TestCSVFileSource:
    """测试CSVFileSource类"""
    
    def test_csv_file_source_import(self):
        """测试CSVFileSource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import CSVFileSource
        assert CSVFileSource is not None
    
    def test_csv_file_source_initialization(self, temp_dir):
        """测试CSVFileSource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        file_path = os.path.join(temp_dir, "test.csv")
        config = {"file_path": file_path, "delimiter": ","}
        
        try:
            source = CSVFileSource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"CSVFileSource initialization failed: {e}")
    
    def test_csv_file_source_execute(self, temp_dir):
        """测试CSVFileSource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 创建测试CSV文件
        file_path = os.path.join(temp_dir, "test.csv")
        csv_content = "id,name,description\n1,项目1,描述1\n2,项目2,描述2\n"
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(csv_content)
        
        config = {"file_path": file_path, "delimiter": ","}
        
        try:
            source = CSVFileSource(config=config)
            result = source.execute(None)
            
            # 验证结果
            assert isinstance(result, (list, dict))
            
        except Exception as e:
            pytest.skip(f"CSVFileSource execution failed: {e}")


@pytest.mark.unit
class TestKafkaSource:
    """测试KafkaSource类"""
    
    def test_kafka_source_import(self):
        """测试KafkaSource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import KafkaSource
        assert KafkaSource is not None
    
    def test_kafka_source_initialization(self):
        """测试KafkaSource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        config = {
            "bootstrap_servers": ["localhost:9092"],
            "topic": "test_topic",
            "group_id": "test_group"
        }
        
        try:
            source = KafkaSource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"KafkaSource initialization failed: {e}")
    
    @patch('sage.apps.libs.io.source.KafkaConsumer')
    def test_kafka_source_execute(self, mock_consumer):
        """测试KafkaSource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 模拟Kafka消费者
        mock_consumer_instance = Mock()
        mock_message = Mock()
        mock_message.value = b'{"test": "message"}'
        mock_consumer_instance.__iter__.return_value = [mock_message]
        mock_consumer.return_value = mock_consumer_instance
        
        config = {
            "bootstrap_servers": ["localhost:9092"],
            "topic": "test_topic",
            "group_id": "test_group"
        }
        
        try:
            source = KafkaSource(config=config)
            result = source.execute(None)
            
            # 验证消费者创建
            mock_consumer.assert_called()
            
        except Exception as e:
            pytest.skip(f"KafkaSource execution failed: {e}")


@pytest.mark.unit
class TestDatabaseSource:
    """测试DatabaseSource类"""
    
    def test_database_source_import(self):
        """测试DatabaseSource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import DatabaseSource
        assert DatabaseSource is not None
    
    def test_database_source_initialization(self):
        """测试DatabaseSource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        config = {
            "connection_string": "sqlite:///test.db",
            "query": "SELECT * FROM test_table"
        }
        
        try:
            source = DatabaseSource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"DatabaseSource initialization failed: {e}")
    
    @patch('sage.apps.libs.io.source.create_engine')
    def test_database_source_execute(self, mock_engine):
        """测试DatabaseSource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 模拟数据库连接
        mock_connection = Mock()
        mock_result = Mock()
        mock_result.fetchall.return_value = [
            ("1", "测试数据1"),
            ("2", "测试数据2")
        ]
        mock_connection.execute.return_value = mock_result
        mock_engine.return_value.connect.return_value.__enter__.return_value = mock_connection
        
        config = {
            "connection_string": "sqlite:///test.db",
            "query": "SELECT * FROM test_table"
        }
        
        try:
            source = DatabaseSource(config=config)
            result = source.execute(None)
            
            # 验证数据库调用
            mock_engine.assert_called_once()
            
        except Exception as e:
            pytest.skip(f"DatabaseSource execution failed: {e}")


@pytest.mark.unit
class TestAPISource:
    """测试APISource类"""
    
    def test_api_source_import(self):
        """测试APISource导入"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        from sage.apps.libs.io_utils.source import APISource
        assert APISource is not None
    
    def test_api_source_initialization(self):
        """测试APISource初始化"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        config = {
            "url": "https://api.example.com/data",
            "method": "GET",
            "headers": {"Authorization": "Bearer token"}
        }
        
        try:
            source = APISource(config=config)
            assert hasattr(source, "config")
            assert hasattr(source, "execute")
        except Exception as e:
            pytest.skip(f"APISource initialization failed: {e}")
    
    @patch('sage.apps.libs.io.source.requests')
    def test_api_source_execute(self, mock_requests):
        """测试APISource执行"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 模拟API响应
        mock_response = Mock()
        mock_response.json.return_value = {"data": "test response"}
        mock_response.status_code = 200
        mock_requests.get.return_value = mock_response
        
        config = {
            "url": "https://api.example.com/data",
            "method": "GET"
        }
        
        try:
            source = APISource(config=config)
            result = source.execute(None)
            
            # 验证API调用
            mock_requests.get.assert_called_once()
            
        except Exception as e:
            pytest.skip(f"APISource execution failed: {e}")


@pytest.mark.integration
class TestSourceIntegration:
    """数据源集成测试"""
    
    def test_multiple_sources_pipeline(self, temp_dir):
        """测试多数据源管道"""
        # 创建模拟数据源
        sources = []
        
        # 文本源
        text_source = Mock()
        text_source.execute.return_value = "文本数据"
        sources.append(("text", text_source))
        
        # JSON源
        json_source = Mock()
        json_source.execute.return_value = {"key": "value"}
        sources.append(("json", json_source))
        
        # API源
        api_source = Mock()
        api_source.execute.return_value = {"api_data": "response"}
        sources.append(("api", api_source))
        
        # 执行所有数据源
        results = {}
        for name, source in sources:
            results[name] = source.execute(None)
        
        assert len(results) == 3
        assert "text" in results
        assert "json" in results
        assert "api" in results
    
    def test_source_chain(self):
        """测试数据源链"""
        # 模拟数据源链：API -> 处理 -> 存储
        
        # 第一个源：API获取数据
        api_source = Mock()
        api_source.execute.return_value = [
            {"id": 1, "text": "数据1"},
            {"id": 2, "text": "数据2"}
        ]
        
        # 第二个源：数据处理
        processor = Mock()
        processor.execute.return_value = [
            {"id": 1, "text": "处理后数据1", "processed": True},
            {"id": 2, "text": "处理后数据2", "processed": True}
        ]
        
        # 第三个源：数据输出
        output_sink = Mock()
        output_sink.execute.return_value = "数据已保存"
        
        # 执行链
        raw_data = api_source.execute(None)
        processed_data = processor.execute(raw_data)
        save_result = output_sink.execute(processed_data)
        
        assert len(raw_data) == 2
        assert len(processed_data) == 2
        assert all(item["processed"] for item in processed_data)
        assert save_result == "数据已保存"


@pytest.mark.external
class TestSourceExternal:
    """数据源外部依赖测试"""
    
    def test_file_not_found_handling(self):
        """测试文件不存在处理"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        config = {"file_path": "/nonexistent/file.txt"}
        
        try:
            source = TextFileSource(config=config)
            
            with pytest.raises((FileNotFoundError, Exception)):
                source.execute(None)
                
        except Exception as e:
            pytest.skip(f"File not found test failed: {e}")
    
    @patch('sage.apps.libs.io.source.requests')
    def test_api_timeout_handling(self, mock_requests):
        """测试API超时处理"""
        if not IO_SOURCE_AVAILABLE:
            pytest.skip("IO Source module not available")
        
        # 模拟网络超时
        mock_requests.get.side_effect = TimeoutError("请求超时")
        
        config = {"url": "https://api.example.com/data", "timeout": 5}
        
        try:
            source = APISource(config=config)
            
            with pytest.raises((TimeoutError, Exception)):
                source.execute(None)
                
        except Exception as e:
            pytest.skip(f"API timeout test failed: {e}")


@pytest.mark.unit
class TestSourceFallback:
    """数据源降级测试"""
    
    def test_source_fallback(self):
        """测试数据源降级"""
        # 模拟简单的数据源
        class SimpleSource:
            def __init__(self, config=None):
                self.config = config or {}
            
            def execute(self, data):
                source_type = self.config.get("type", "default")
                return f"数据来自{source_type}源"
        
        # 测试不同类型的源
        text_source = SimpleSource({"type": "文本"})
        json_source = SimpleSource({"type": "JSON"})
        api_source = SimpleSource({"type": "API"})
        
        text_result = text_source.execute(None)
        json_result = json_source.execute(None)
        api_result = api_source.execute(None)
        
        assert "文本" in text_result
        assert "JSON" in json_result
        assert "API" in api_result
    
    def test_basic_file_reading(self, temp_dir):
        """测试基本文件读取"""
        # 创建测试文件
        file_path = os.path.join(temp_dir, "simple.txt")
        test_content = "简单测试内容"
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(test_content)
        
        # 简单文件读取
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        assert content == test_content
